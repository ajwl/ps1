---
layout: post
title: 'New site: Loading Jekyll on Sinatra and deploying on Heroku'
date: 2016-10-25 21:30:15.000000000 +01:00
type: post
published: false
status: draft
categories: []
tags:
- web development
meta:
  _edit_last: '1'
author: annaleach
---

It was time to refresh my personal blog, so I pulled the content off the old wordpress template I'd had it on, 
and built a custom website in the ruby framework Sinatra, using the ruby-based blog creator Jekyll.

<!--excerpt-->

My wordpress site had been running since 2012, I was getting a bit fed up with how hard it was to change the CSS, and I 
wanted a domain where I could easily host other code projects.  

The first step was to grab the old content. There weren't loads of posts but I wanted to transfer them and all the metadata. 

### Converting the content out of Wordpress

This blog [how to migrate from wordpress to jekyll](http://vitobotta.com/how-to-migrate-from-wordpress-to-jekyll/) was the most helpful by far. 
Though I ended up picking and choosing exactly what to follow. 

You can quickly export all your blog posts and metadata from wordpress, but they come out in a zip file surrounded by a lot of junk html. 

He recommends using a [gem Downmarkit](https://github.com/cousine/downmark_it) to load in the html posts and turn out text formatted in markdown, the format that Jekyll blogs 
are written in. This was very helpful. 

I ended up having to modify the resulting markdown files a bit, but this proved to be a godsend, becuase it was a fairly quick way 
to clean up a lot of files. And it autogenerated not just formatting but the front-matter (key: value headings for attributes 
like author and publication date) that Jekyll uses as metadata.

This is the translator.rb script I used to run the posts through the DownMarkit convertor. Of course you'll need to change the directory locations
to match your project. This prints out the markdown after the html, something I wanted to do so I could check it was working.  

```ruby 
%w(active_support rubygems sequel fileutils yaml active_support/inflector).each{ | g |
  require g}

require_relative 'downmark_it/downmark_it'

all_files = Dir[ 'blog/_posts', '_posts/*.html']

def transform(all_files)
  all_files.each do |file|

    blogpost = File.open(file, "r+")
    contents = blogpost.read

    content = DownmarkIt.to_markdown contents
    blogpost.write content
    blogpost.close
  end
end

transform(all_files)
```

## Getting Jekyll to work 

Once I had the folder of markdown posts, I put them into a [traditional Jekyll folder structure](https://jekyllrb.com/docs/structure/). 
There are a lot of helpful guides on the Jekyll website, a gem that lets you [get a boilerplate site](https://jekyllrb.com/docs/quickstart/) off the ground quickly,
 plus examples of how a vanilla jekyll project works. 

## Getting Sinatra and Jekyll to work together 

However, it was when I got to mounting the Jekyll blog on a basic Sinatra framework, that I got frustrated to the extent
 that I wished I hadn't used Jekyll. 

### 1) Directory structure 

After faffing around with the Jekyll and Sinatra parts in entirely separate diretories, and then having them all in the same 
root directory, I eventually figured out the current structure, that can be seen [in the site github](https://github.com/ajwl/ps1). 

### 2) Build a Sinatra route to pick up the rendered html display it as a webpage. 

This post by [Derek Eder on setting up a Jekyll blog in Sinatra](http://derekeder.com/blog/hello-world-setting-up-a-jekyll-blog-in-sinatra)
was particularly helpful. Basically, given that you have a directory of newly-minted html files, make sure they can be found when someone
clicks on a link like http://mysite.com/blog/this-great-post.

The route below takes all requests to the site starting with /blog and grabs  `blog/this-great-post` from the request object. 

```ruby
  get '/blog/?*' do
    jekyll_blog(request.path_info)
  end
```

You'll notice it takes the path and sends off to a method `jekyll_blog`. This is what that method does:

```ruby
  def jekyll_blog(path)
    file_path = File.join(File.dirname(__FILE__), '_site', path.gsub('/blog', ''))
    file_path = File.join(file_path, 'blog.html') unless file_path =~ /\.[a-z]+$/i

    if File.exist?(file_path)
      file = File.open(file_path, 'r')
      contents = file.read
      file.close
    end
    contents
  end

```
The first two lines look confusing, but all the first one does is change the `blog/this-great-post` name and turn it into 
`http://mysite.com/_site/this-great-post`
- the location at which the corresponding blog post can actually be found. 

`File.join` returns a new string formed by joining the strings using a slash.  

The second line returns the blog homepage if illegal characters are found in the url requested. 

If a file exists at that location, sinatra opens it, reads it out and serves up its contents, ie. a full html file. 

### 3) Images and assets 

### 4) Exclude all the Sinatra crap that gets tangled up in Jekyll.

Use the excludes: setting in Jekyll's configuration file  

### 5) Create a dev and environments with Jk

See [all the code](https://github.com/ajwl/ps1) 


## Deploying the lot to Heroku 

Heroku is nice to use. However a few quirks of how I set up the site made this harder 
than I expected to deploy. Despite seeing advice to use the PHP engine and to install various buildpacks 
I ended up just using the Ruby build engine. 

Critically, setting a Procfile helped a lot. Really, all the site needs to do is build the jekyll site *before* running the 
 Sinatra commands. Then when Sinatra runs on the `serve` command, the posts are all prebuilt as html files, and Sinatra has no need to know how 
 they got there. 

This is my simple Procfile:

```
web: jekyll build && serve
```

If you're getting strange errors from the jekyll build command, one command that helped me was adding even more to
the excludes array in Jekyll's `config.yml` file.

```
exclude: ['views', 'Gemfile', 'app.rb', 'config.ru', 'README.md', 'Gemfile.lock', 'vendor', 'bin']
```

As the name suggests, `exclude` stops Jekyll trying to render stuff that is to do with Sinatra. This saved me a headache.


